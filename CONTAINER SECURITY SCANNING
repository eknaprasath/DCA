Docker containers can have security vulnerabilites
If blindly pulled and if containers are running in production, it can result in breach.

DTR allows us to perform security scan for the containers.
These scan can perform "On Push" or even manually


CONFIGURE CONTAINER SCANNING WITH DTR

Enable the vulnerability scanning features and try with pushing the image to repo

OVERVIEW OF UCP CLIENT BUNDLES

  A client bundle is a group of certificates downloadable directly from the Docker Universal Control Plane (UCP)
  
  Depending on the permission associated with the user, you can now execute docker swarm commands from your remote machine that take effect on the remote cluster
  
For example:

  * You can create a new service in UCP from your laptop.
  * Login to remote container from your laptop without SSH (Via API)
  

UCP Client bundle is associated with user so we can find them from -> my profile
create a new bundle and download the bundle

launch a container

docker container run -it -dt --name myubuntu ubuntu bash

docker ps
docker cp "ucp-bundle-admin.zip" myubuntu:/tmp

docker container exec -it myubuntu bash
cd /
mkdir /ucp
cp /tmp/ucp-bundle-admin.zip /ucp
apt-get update
apt-get install unzip

unzip ucp-bundle-admin
nano env.sh


eval "$(<env.sh)"

to verify 
echo $DOCKER_HOST

curl -sSL https://get.docker.com/ | sh

docker service create --name mydemoservice nginx

goto ucp gui and check for the created service


INTEGRATING LDAP WITH UCP

Goto admin setting -->Authentication & Authorization --> LDAP ENABLE 

LINUX NAMESPACES

Docker uses a technology called namespaces to provide the isolated work space called the container
The namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.

Namespace A                         Namespace B
UTS PID                             UTS   PID

docker container run -dt --name mybusybox busybox sh
docker ps
ps -ef

docker container exec -it mybusybox bash

ps -ef 

unshare -fp --mount-proc /bin/bash

unshare --uts /bin/bash
hostname
hostname mynamespace

Currently Linux provides six different types of namespaces as follows:

* Inter-Process Communication (IPC)
* Process(PID)
* Network(net)
* User Id (user)
* Mount (mnt)
* UTS

CONTROL GROUPS (CGROUPS)
Control groups (cgroups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage(CPU,memory,disk I/O, network, etc.)
of a collection of processes.

Control grups is a Linux kernal feature but docker support primaryly CPU and Memory

LIMITING MEMORY

docker run --help
-m or --memory in bytes

docker container run -dt --name mymemory01 -m 256m busybox
docker container exec -it mymemory01 sh

free -m

cat /sys/fs/cgroup/memory/memory.limit_in_bytes


LIMITING CPU
docker run --help

There are various ways in which you can limit the CPU for containers, these include:

Approaches                        `Description
--cpus=<value>            If you has 2 CPUs and if you set --cpus=1 then container is guranteed at most one CPU. you can even specify --cpu=0.5

--cpuset-cpus             Limit the specific CPUs of cores a container can use. A comma-separated list or hyphen-separated range of CPUs a container can use
                          1st CPU is numbered 0
                          2nd CPU is numbered 1
                          
                          Value of 0-3 means usage of first, second, third and fourch CPU.
                          Value of 1,3 means second and fourth CPU.



docker container run -dt --name mycpu01 --cpus=1.5 busybox sh

docker container run -dt --name cpu3 --cpuset-cpus=0,1 busybox sh 


RESERVATIN VS LIMIT

  By default, a container has no resource constraints and can use much of a given resource as the host's kernel scheduler allows.
  
  It is important not to allow a running container to consume too much of the host machine's memory.
  
  One Linux hosts, if the kernel detects that there is not enough memory to perform important system functions, it throws an "Out Of Memory" exception,
  and starts killing processes to free up memory.
  
  
  Limit imposes an upper limit to the amount of memory that can potentially be used by a Docker container.
  
  Reservations, on the other hand, is less rigid.
  
  When the system is running low on memory and there is contention, reservation tries to bring the container's memory consumption at or
  below the reservation limit.
  
  LIMIT is hard limit
  RESERVATION is soft limit
  
  
  docker container run -dt --name container01 --memory-reservation 250m busybox sh #soft limit
  
  docker container run -dt --name container02 -m 500m --memory-reservation 250m busybox sh #hard limit with softlimit reservation
  




